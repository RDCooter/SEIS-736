package edu.stthomas.gps.project;

import java.io.IOException;
import java.text.NumberFormat;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Counter;
import org.apache.hadoop.mapreduce.Counters;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.KeyValueTextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.log4j.Logger;

/**
 * 
 * @author Robert Driesch - UST Id# 101058113
 * @version 1.0, December 1, 2014
 **/
public class SimpleMonthCount extends Configured implements Tool {
	private static final Logger LOG = Logger.getLogger(SimpleMonthCount.class);

	public static enum NEISS_DATA {
		TOAL_RECORDS_PROCESSED
	}

	/**
	 * @version 1.0, December 1, 2014
	 **/
	public static class SimpleMonthCountMapper extends Mapper<Text, Text, Text, IntWritable> {

		/*
		 * Local Cache Variables for the <key,value> for reuse for each input record being processed.
		 */
		private Text xWordKey = new Text();

		private static final IntWritable ONE_COUNT = new IntWritable(1);
		private static final String TAB_DELIMITER = new String("\t");

		/**
		 * Read the filtered NEISS data and calculate the frequency of the incidents for each month. This is essentially
		 * a simple WordCount algorithm over the month portion of the TreatmentDate.
		 * <p>
		 * 
		 * @param aKey a simple text key that represents the CaseNbr
		 * @param aValue a tab delimited text string with the last field as the incident Description
		 * @param aContext the context object associated with this process
		 **/
		@Override
		protected void map(Text aKey, Text aValue, Context aContext) throws IOException, InterruptedException {

			// @formatter:off
			/*
			 * Expects a line of input like the following: 
			 * 				[KEY(Text(CaseNbr))	VALUE(Text(TreatmentDate
			 * 												\tHospital
			 *		 										\tWeight
			 * 												\tStratum
			 * 												\tAge
			 * 												\tGender
			 * 												\tRace
			 * 												\tDiagnosis
			 *												\tBodyPart
			 * 												\tDisposition
			 * 												\tLocation
			 * 												\tProducts
			 * 												\tDescription))]
			 */
			 // @formatter:on

			/*
			 * Get the TreatmentDate from the tab delimited value in the <key,value> pair so we can extract out the month
			 * portion to summarize the number of incidents by month.
			 */
			String treatmentDate = aValue.toString().split(TAB_DELIMITER)[0];

			// @formatter:off
			/*
			 * Write the output record in the following format: 
			 * 		[KEY(Text(TreatmentMonth))  VALUE(IntWritable(1))]
			 */
			// @formatter:on
			xWordKey.set(treatmentDate.split("/")[0]);// Date in MDY format with "/" as the separator
			aContext.write(xWordKey, ONE_COUNT);
			aContext.getCounter(NEISS_DATA.TOAL_RECORDS_PROCESSED).increment(1);
		}
	}

	/**
	 * @version 1.0, December 1, 2014
	 **/
	public static class SimpleMonthSumReducer extends Reducer<Text, IntWritable, Text, Text> {
		private static final NumberFormat PERCENT_FORMAT = NumberFormat.getPercentInstance();

		/*
		 * Local Cache Variables for the <key, value> for reuse for each output reduce record being processed.
		 */
		private Text xTextValue = new Text();

		private static final String SPACE_DELIMITER = new String(" ");

		/**
		 * Read all of the <key, List(values)> pairs generated by the Mapper<> and determine the number of times that we
		 * encounter an incident for a particular month and group those counts based upon the month (key).
		 * <p>
		 * 
		 * @param aKey a Text value key that represents the month within the treatment date of the incident
		 * @param aValues an iterable array of counts of the incidents found across the values for the key
		 * @param aContext the context object associated with this process
		 **/
		@Override
		protected void reduce(Text aKey, Iterable<IntWritable> aValues, Context aContext) throws IOException,
				InterruptedException {

			/*
			 * Loop through all of the values collected for each key (TreatmentMonth) from the Mapper<> and summarize the
			 * total number of incidents that occurred during that month within the data.
			 */
			int myMonthCount = 0;
			for (IntWritable myValue : aValues) {
				myMonthCount += myValue.get();
			}

			/*
			 * Calculate the percentage of incidents that occurred during this month across the entire population of years. 
			 */
			double percentOfTotalIncidents = (double) myMonthCount
					/ (double) aContext.getConfiguration().getInt("wordcount.total.incidents", 1);

			/*
			 * Build up the Format of the New Value:
			 * "[ Total=SUM(IncidentCount)  PercentTotalAllYears=(SUM(IncidentCount)/TotalIncidents) ]"
			 */
			StringBuilder textValueBuilder = new StringBuilder();
			textValueBuilder.append("[");
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("Total=");
			textValueBuilder.append(String.valueOf(myMonthCount));
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("PercentTotalAllYears=");
			textValueBuilder.append(PERCENT_FORMAT.format(percentOfTotalIncidents));
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("]");

			// @formatter:off
			/*
			 * Write the output record in the following format: 
			 * 		[KEY(Text(TreatmentMonth))
			 * 			VALUE(Text(<[ Total=SUM(IncidentCount)  PercentTotalAllYears=(SUM(IncidentCount)/TotalIncidents) ]>))]
			 */
			// @formatter:on
			xTextValue.set(textValueBuilder.toString());
			aContext.write(aKey, xTextValue);
		}
	}

	/**
	 * Setup the environment so that we can invoke the Mapper as a mapper-only job to perform the simple filtering of
	 * the initial data.
	 * 
	 * @param aArguments the arguments that were passed into the program
	 **/
	@Override
	public int run(String[] aArguments) throws Exception {
		final String usageText = "Usage: SimpleMonthCount <input_dir> <output_dir> -totalIncidents n";

		Job job = new Job(getConf());

		/*
		 * Process any arguments passed in...
		 */
		if (aArguments.length > 0) {
			for (int i = 0; i < aArguments.length; i++) {
				if (i == 0) {
					FileInputFormat.setInputPaths(job, new Path(aArguments[i]));
				} else if (i == 1) {
					FileOutputFormat.setOutputPath(job, new Path(aArguments[i]));
				} else if ("-totalIncidents".equals(aArguments[i])) {
					i += 1; // Bump to the value
					job.getConfiguration().setLong("wordcount.total.incidents", Integer.parseInt(aArguments[i]));
					LOG.info("Added " + aArguments[i]
							+ " total unique incidents from the data files for use in calculations.");
				} else {
					System.err.println("ERROR: Invalid argument : '" + aArguments[i] + "'");
					LOG.info(usageText);
					return -1;
				}
			}
		}

		job.setJarByClass(SimpleMonthCount.class);
		job.setJobName("NEISS Report - Incidents by Month");

		job.setMapperClass(SimpleMonthCountMapper.class);
		job.setReducerClass(SimpleMonthSumReducer.class);

		job.setMapOutputKeyClass(Text.class);
		job.setMapOutputValueClass(IntWritable.class);

		job.setOutputKeyClass(Text.class);
		job.setOutputValueClass(IntWritable.class);

		job.setInputFormatClass(KeyValueTextInputFormat.class);
		job.setOutputFormatClass(TextOutputFormat.class);

		job.setNumReduceTasks(1);

		/*
		 * Run the job and wait for it to be completed.
		 */
		boolean success = job.waitForCompletion(true);

		/*
		 * Quickly output the local counters to the local output stream (console).
		 */
		Counters allCounters = job.getCounters();
		Counter myCounter = allCounters.findCounter(NEISS_DATA.TOAL_RECORDS_PROCESSED);
		LOG.info(myCounter.getDisplayName() + " : " + myCounter.getValue());

		return success ? 0 : 1;
	}

	/**
	 * The main method calls the ToolRunner.run method, which in turn calls an options parser that interprets Hadoop
	 * command-line options and puts them into a Configuration object.
	 * 
	 * @param aArguments the arguments that were passed into the program
	 **/
	public static void main(String[] aArguments) throws Exception {
		int exitCode = ToolRunner.run(new Configuration(), new SimpleMonthCount(), aArguments);
		System.exit(exitCode);
	}
}
