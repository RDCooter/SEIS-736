package edu.stthomas.gps.project;

import java.io.IOException;
import java.text.NumberFormat;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.conf.Configured;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.io.IntWritable;
import org.apache.hadoop.io.Text;
import org.apache.hadoop.mapreduce.Counter;
import org.apache.hadoop.mapreduce.Counters;
import org.apache.hadoop.mapreduce.Job;
import org.apache.hadoop.mapreduce.Mapper;
import org.apache.hadoop.mapreduce.Partitioner;
import org.apache.hadoop.mapreduce.Reducer;
import org.apache.hadoop.mapreduce.lib.input.FileInputFormat;
import org.apache.hadoop.mapreduce.lib.input.KeyValueTextInputFormat;
import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;
import org.apache.hadoop.mapreduce.lib.output.TextOutputFormat;
import org.apache.hadoop.util.Tool;
import org.apache.hadoop.util.ToolRunner;
import org.apache.log4j.Logger;

/**
 * 
 * @author Robert Driesch - UST Id# 101058113
 * @version 1.0, December 1, 2014
 **/
public class SimpleAgeCount extends Configured implements Tool {
	private static final Logger LOG = Logger.getLogger(SimpleAgeCount.class);

	public static enum NEISS_DATA {
		TOAL_RECORDS_PROCESSED
	}

	/**
	 * @version 1.0, December 1, 2014
	 **/
	public static class AgePartitioner extends Partitioner<Text, Text> {

		// @formatter:off
		/**
		 * Read the <key, value> pair generated by the Mapper and use the numeric age to determine the what range 
		 * this patient will fall into and which reducer this incident record should be routed towards. The 
		 * goal is to have the data from each age category routed to a different reducer so when 11 Reduce 
		 * Tasks are used, then each task should only be processing records that match their age category.
		 * <p>
		 * 
		 * Expects a line of input like the following: 
		 * 				[KEY(Text(Age))	VALUE(IntWritable(1))]
		 * <p>
		 * 
		 * @param aKey a simple text key that represents the Age
		 * @param aValue a count of the incidents found for this key
		 * @param aNumReduceTasks the number of Reduce Tasks allocated for this process
		 **/
		// @formatter:on
		@Override
		public int getPartition(Text aKey, Text aValue, int aNumReduceTasks) {
			/*
			 * Perform a sanity test to avoid any divide by zero exceptions (modulus with zero) when the number of
			 * reducers is set to zero for some reason.
			 */
			if (aNumReduceTasks == 0) {
				return 0;
			}

			/*
			 * Get the Age from the key in the <key,value> pair so we can determine what category it belongs to for use
			 * for the partitioning.
			 */
			int ageInt = Integer.parseInt(aKey.toString());

			/*
			 * Set the partition number based upon the range that this age falls into in order to keep the output
			 * results grouped based upon the same category that was using in the CPSC reports.
			 */
			if (ageInt >= 0 && ageInt <= 4)
				return 0 % aNumReduceTasks;
			else if (ageInt >= 5 && ageInt <= 9)
				return 1 % aNumReduceTasks;
			else if (ageInt >= 10 && ageInt <= 14)
				return 2 % aNumReduceTasks;
			else if (ageInt >= 15 && ageInt <= 19)
				return 3 % aNumReduceTasks;
			else if (ageInt >= 20 && ageInt <= 24)
				return 4 % aNumReduceTasks;
			else if (ageInt >= 25 && ageInt <= 29)
				return 5 % aNumReduceTasks;
			else if (ageInt >= 30 && ageInt <= 34)
				return 6 % aNumReduceTasks;
			else if (ageInt >= 35 && ageInt <= 39)
				return 7 % aNumReduceTasks;
			else if (ageInt >= 40 && ageInt <= 44)
				return 8 % aNumReduceTasks;
			else if (ageInt >= 45 && ageInt <= 49)
				return 9 % aNumReduceTasks;
			else
				return 10 % aNumReduceTasks;
		}
	}

	/**
	 * @version 1.0, December 1, 2014
	 **/
	public static class SimpleAgeCountMapper extends Mapper<Text, Text, Text, IntWritable> {

		/*
		 * Local Cache Variables for the <key,value> for reuse for each input record being processed.
		 */
		private Text xWordKey = new Text();

		private static final IntWritable ONE_COUNT = new IntWritable(1);
		private static final String TAB_DELIMITER = new String("\t");

		/**
		 * Read the filtered NEISS data and calculate the frequency of the incidents for each age category. This is
		 * essentially a simple WordCount algorithm over the Ager field.
		 * <p>
		 * 
		 * @param aKey a simple text key that represents the CaseNbr
		 * @param aValue a tab delimited text string with the 5th field as the patients Age
		 * @param aContext the context object associated with this process
		 **/
		@Override
		protected void map(Text aKey, Text aValue, Context aContext) throws IOException, InterruptedException {

			// @formatter:off
			/*
			 * Expects a line of input like the following: 
			 * 				[KEY(Text(CaseNbr))	VALUE(Text(TreatmentDate
			 * 												\tHospital
			 *		 										\tWeight
			 * 												\tStratum
			 * 												\tAge
			 * 												\tGender
			 * 												\tRace
			 * 												\tDiagnosis
			 *												\tBodyPart
			 * 												\tDisposition
			 * 												\tLocation
			 * 												\tProducts
			 * 												\tDescription))]
			 */
			 // @formatter:on

			/*
			 * Get the Age from the tab delimited value in the <key,value> pair so we can extract out the age value in
			 * order to summarize the number of incidents by age categories.
			 */
			String ageValue = aValue.toString().split(TAB_DELIMITER)[4];

			// @formatter:off
			/*
			 * Write the output record in the following format: 
			 * 		[KEY(Text(Ager))  VALUE(IntWritable(1))]
			 */
			// @formatter:on
			xWordKey.set(ageValue);
			aContext.write(xWordKey, ONE_COUNT);
			aContext.getCounter(NEISS_DATA.TOAL_RECORDS_PROCESSED).increment(1);
		}
	}

	/**
	 * @version 1.0, December 1, 2014
	 **/
	public static class SimpleAgeSumReducer extends Reducer<Text, IntWritable, Text, Text> {
		private static final NumberFormat PERCENT_FORMAT = NumberFormat.getPercentInstance();

		/*
		 * Local Cache Variables for the <key, value> for reuse for each output reduce record being processed.
		 */
		int xAgeValue;
		int xAgeCount = 0;// Must persist across method calls
		private Text xTextKey = new Text();
		private Text xTextValue = new Text();

		private static final String SPACE_DELIMITER = new String(" ");

		/**
		 * Read all of the <key, List(values)> pairs generated by the Mapper<> and determine the number of times that we
		 * encounter an incident for a particular age category and group those counts based upon the age (key).
		 * <p>
		 * 
		 * @param aKey a Text value key that represents the age value of the patient involved in the incident
		 * @param aValues an iterable array of counts of the incidents found across the values for the key
		 * @param aContext the context object associated with this process
		 **/
		@Override
		protected void reduce(Text aKey, Iterable<IntWritable> aValues, Context aContext) throws IOException,
				InterruptedException {

			/*
			 * Get the Age value from the key in the <key,value> pair so we can remember what category this reducer is
			 * responsible for building. It does not which one we remember since all of the different values in the
			 * <key,value> pairs should belong to the same category. This is why we simply get the value every time.
			 */
			xAgeValue = Integer.parseInt(aKey.toString());

			/*
			 * Loop through all of the values collected for each key (Age) from the Mapper<> and summarize the total
			 * number of incidents that occurred for that age within the data.
			 */
			for (IntWritable myValue : aValues) {
				xAgeCount += myValue.get();
			}
		}

		/**
		 * Cleanup and unload all of the internal data structures and write the summarization record out to the context.
		 * This Reducer takes advantage of the fact that the only <key,value> that it will interrogate are the ones that
		 * belong to the same age category.
		 * 
		 * @param aContext the context object associated with this process
		 **/
		@Override
		protected void cleanup(Context aContext) throws java.io.IOException, InterruptedException {

			/*
			 * Calculate the percentage of incidents that occurred for this age category across the entire population of
			 * years.
			 */
			double percentOfTotalIncidents = (double) xAgeCount
					/ (double) aContext.getConfiguration().getInt("wordcount.total.incidents", 1);

			/*
			 * Build up the Format of the New Value:
			 * "[ Total=SUM(IncidentCount)  PercentTotalAllYears=(SUM(IncidentCount)/TotalIncidents) ]"
			 */
			StringBuilder textValueBuilder = new StringBuilder();
			textValueBuilder.append("[");
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("Total=");
			textValueBuilder.append(String.valueOf(xAgeCount));
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("PercentTotalAllYears=");
			textValueBuilder.append(PERCENT_FORMAT.format(percentOfTotalIncidents));
			textValueBuilder.append(SPACE_DELIMITER);
			textValueBuilder.append("]");

			/*
			 * Build up the Format of the New Key:
			 * "[ AgeCategoryDescription ]"
			 */
			StringBuilder textKeyBuilder = new StringBuilder();
			textKeyBuilder.append("[");
			textKeyBuilder.append(SPACE_DELIMITER);
			if (xAgeValue >= 0 && xAgeValue <= 4)
				textKeyBuilder.append("0-4");
			else if (xAgeValue >= 5 && xAgeValue <= 9)
				textKeyBuilder.append("5-9");
			else if (xAgeValue >= 10 && xAgeValue <= 14)
				textKeyBuilder.append("10-14");
			else if (xAgeValue >= 15 && xAgeValue <= 19)
				textKeyBuilder.append("15-19");
			else if (xAgeValue >= 20 && xAgeValue <= 24)
				textKeyBuilder.append("20-24");
			else if (xAgeValue >= 25 && xAgeValue <= 29)
				textKeyBuilder.append("25-29");
			else if (xAgeValue >= 30 && xAgeValue <= 34)
				textKeyBuilder.append("30-34");
			else if (xAgeValue >= 35 && xAgeValue <= 39)
				textKeyBuilder.append("35-39");
			else if (xAgeValue >= 40 && xAgeValue <= 44)
				textKeyBuilder.append("40-44");
			else if (xAgeValue >= 45 && xAgeValue <= 49)
				textKeyBuilder.append("45-49");
			else
				textKeyBuilder.append("50-99");
			textKeyBuilder.append(SPACE_DELIMITER);
			textKeyBuilder.append("]");

			// @formatter:off
			/*
			 * Write the output record in the following format: 
			 * 		[KEY(Text(<AgeCategoryDescription>))
			 * 			VALUE(Text(<[ Total=SUM(IncidentCount)  PercentTotalAllYears=(SUM(IncidentCount)/TotalIncidents) ]>))]
			 */
			// @formatter:on
			xTextValue.set(textValueBuilder.toString());
			xTextKey.set(textKeyBuilder.toString());
			aContext.write(xTextKey, xTextValue);
		}
	}

	/**
	 * Setup the environment so that we can invoke the Mapper as a mapper-only job to perform the simple filtering of
	 * the initial data.
	 * 
	 * @param aArguments the arguments that were passed into the program
	 **/
	@Override
	public int run(String[] aArguments) throws Exception {
		final String usageText = "Usage: SimpleAgeCount <input_dir> <output_dir> -totalIncidents n";

		Job job = new Job(getConf());

		/*
		 * Process any arguments passed in...
		 */
		if (aArguments.length > 0) {
			for (int i = 0; i < aArguments.length; i++) {
				if (i == 0) {
					FileInputFormat.setInputPaths(job, new Path(aArguments[i]));
				} else if (i == 1) {
					FileOutputFormat.setOutputPath(job, new Path(aArguments[i]));
				} else if ("-totalIncidents".equals(aArguments[i])) {
					i += 1; // Bump to the value
					job.getConfiguration().setLong("wordcount.total.incidents", Integer.parseInt(aArguments[i]));
					LOG.info("Added " + aArguments[i]
							+ " total unique incidents from the data files for use in calculations.");
				} else {
					System.err.println("ERROR: Invalid argument : '" + aArguments[i] + "'");
					LOG.info(usageText);
					return -1;
				}
			}
		}

		job.setJarByClass(SimpleAgeCount.class);
		job.setJobName("NEISS Report - Incidents by Age");

		job.setMapperClass(SimpleAgeCountMapper.class);
		job.setReducerClass(SimpleAgeSumReducer.class);
		job.setPartitionerClass(AgePartitioner.class);

		job.setMapOutputKeyClass(Text.class);
		job.setMapOutputValueClass(IntWritable.class);

		job.setOutputKeyClass(Text.class);
		job.setOutputValueClass(IntWritable.class);

		job.setInputFormatClass(KeyValueTextInputFormat.class);
		job.setOutputFormatClass(TextOutputFormat.class);

		job.setNumReduceTasks(11);

		/*
		 * Run the job and wait for it to be completed.
		 */
		boolean success = job.waitForCompletion(true);

		/*
		 * Quickly output the local counters to the local output stream (console).
		 */
		Counters allCounters = job.getCounters();
		Counter myCounter = allCounters.findCounter(NEISS_DATA.TOAL_RECORDS_PROCESSED);
		LOG.info(myCounter.getDisplayName() + " : " + myCounter.getValue());

		return success ? 0 : 1;
	}

	/**
	 * The main method calls the ToolRunner.run method, which in turn calls an options parser that interprets Hadoop
	 * command-line options and puts them into a Configuration object.
	 * 
	 * @param aArguments the arguments that were passed into the program
	 **/
	public static void main(String[] aArguments) throws Exception {
		int exitCode = ToolRunner.run(new Configuration(), new SimpleAgeCount(), aArguments);
		System.exit(exitCode);
	}
}
